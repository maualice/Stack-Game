<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10 - Stack Game</title>
    <style>
        body{
            background: #000 ;
            margin: 0;
            display: grid;
            place-content: center;/*place-content: <align-content> <justify-content>;*/
        }

        canvas{
            border: 1px solid white;
        }
    </style>

    <script type="module">/*module para qeu se carga en forma defer,es decir despues que se cargo el html,para que si en script busco obtener el canvas lo va a reconocer,sin esto da null y al utilizarlo erro ya que ejecuta script antes que html*//*se podria usar <script defer src=""> pero es mejor module porque ademas debe ser archivos externos*/
        const canvas=document.querySelector('canvas')
        const context=canvas.getContext('2d')/**/

        const MODES={
            FALL:'fall',
            BOUNCE:'bounce',
            GAMEOVER:'gameover'
        }
        const INITIAL_BOX_WIDTH=200 /*tamaño inicial de la caja*/
        const INITIAL_BOX_Y=600 /*posicion inicial de la caja*/

        const BOX_HEIGHT=50
        const INITIAL_Y_SPEED=5
        const INITIAL_X_SPEED=2

        //STATE
        let boxes=[]
        let scrollCounter,cameraY,current,mode,xSpeed,ySpeed /*scrollcounter porque va a ir subiendo el scroll a medidad que se va jugando,current seria la caja con la que se esta jugando,seria como la puntuacion*/

        function createStepColor(step){
            if(step === 0) return 'white'

            const red=Math.floor(Math.random()*255)/*Math.random genera un numero decimal aleatorio entre 0 y 255, redondear un número hacia abajo al entero más cercano*/
            const green=Math.floor(Math.random()*255)
            const blue=Math.floor(Math.random()*255)

            return `rgb(${red},${green},${blue})`
        }   

        function updateCamera(){
            if(scrollCounter>0){
               cameraY++ 
               scrollCounter--
            }
        }

        function initializeGameState(){
            boxes=[{
                x:canvas.width / 2 - INITIAL_BOX_WIDTH / 2,
                y:200,
                width:INITIAL_BOX_WIDTH,
                color:'white'
            }]

            current = 1
            mode=MODES.BOUNCE
            xSpeed=INITIAL_X_SPEED
            ySpeed=INITIAL_Y_SPEED
            scrollCounter=0
            cameraY=0

            createNewBox()
        }

        function restart(){
            initializeGameState()
            draw()
        }

        function draw(){
            if(mode === MODES.GAMEOVER) return

            drawBackground()
            drawBoxes()

            if(mode === MODES.BOUNCE) {
                moveAndDetectCollision()
            }else if(mode === MODES.FALL){
                updateFallMode()
            }

            updateCamera()

            window.requestAnimationFrame(draw)/*le pasas una función que quieres ejecutar antes del siguiente repintado*/
        }

        function drawBackground(){
            context.fillStyle='rgba(0, 0, 0, 0.5)'
            context.fillRect(0,0,canvas.width,canvas.height)
        }

        function drawBoxes(){
            boxes.forEach((box)=>{ /*no usar map porque map devulve un nuevo array,y aca no se necesita*/
                const {x,y,width,color}=box
                const newY=INITIAL_BOX_Y - y + cameraY

                context.fillStyle = color
                context.fillRect(x,newY,width,BOX_HEIGHT)
            })
        }

        function createNewBox(){
            boxes[current]={
                x: 0,
                y: (current + 10) * BOX_HEIGHT,
                width:boxes[current - 1].width,
                color: createStepColor(current)
            }
        }

        function updateFallMode(){
            const currentBox = boxes[current]
            currentBox.y -= ySpeed

            const positionPreviousBox=boxes[current - 1].y + BOX_HEIGHT /*posicion y de la caja previa mas su altura*/

            if(currentBox.y === positionPreviousBox){
                handleBoxLanding()
            }
        }
        
        function adjustCurrentBox(){
            const currentBox=boxes[current]
            const previousBox=boxes[current- 1]

            if(currentBox.x > previousBox.x){
                console.log('sobre caja por la derecha');
                currentBox.width -= difference
            }else{
                currentBox.width += difference
                currentBox.x=previousBox.x
                console.log('sobre caja por la izquierda');
            }
        }


        function handleBoxLanding(){
            const currentBox=boxes[current]
            const previousBox=boxes[current-1]

            const difference=currentBox.x-previousBox.x

            if(Math.abs(difference) >= currentBox.width){
                mode=MODES.GAMEOVER
                return
            }

            adjustCurrentBox(difference)

            xSpeed += xSpeed > 0 ? 1 : -1 /*le aumenta la velocidad cada vez que baje una caja, positivo para la derecha o negativo si va a la izq*/
            current++ /*numero de caja,que coincide con la puntuacion*/
            scrollCounter=BOX_HEIGHT
            mode=MODES.BOUNCE

            createNewBox()
        }

        function moveAndDetectCollision(){
            const currentBox = boxes[current]
            currentBox.x += xSpeed

            const isMovingRight=xSpeed>0
            const isMovingLeft=xSpeed<0

            const hasHitRightSide=currentBox.x + currentBox.width > canvas.width

            const hasHitLeftSide=currentBox.x < 0
            
            if((isMovingRight && hasHitRightSide)|| (isMovingLeft && hasHitLeftSide)){
                xSpeed *= -1
            }
        }

        document.addEventListener('keydown',(event) => {
            if(event.key === ' ' && mode === MODES.BOUNCE){
                mode=MODES.FALL
            }
        })

        restart()
    </script>
</head>
<body>
    <canvas id="canvas" width="320" height="500"></canvas>
</body>
</html>